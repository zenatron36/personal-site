import { promises as fs } from 'fs';
import { join } from 'path';
import globToRegExp from 'glob-to-regexp';
import { getPackageVersion } from './package_json.js';
import { nonNullable } from './utils/non_nullable.js';
const serializePattern = (regex) => regex.source.replace(/\\\//g, '/');
const generateManifest = ({ bundles = [], declarations = [], functions, importMap, layers = [], }) => {
    const preCacheRoutes = [];
    const postCacheRoutes = [];
    declarations.forEach((declaration) => {
        const func = functions.find(({ name }) => declaration.function === name);
        if (func === undefined) {
            return;
        }
        const pattern = getRegularExpression(declaration);
        const route = {
            function: func.name,
            name: declaration.name,
            pattern: serializePattern(pattern),
        };
        const excludedPattern = getExcludedRegularExpression(declaration);
        if (excludedPattern) {
            route.excluded_pattern = serializePattern(excludedPattern);
        }
        if (declaration.cache === "manual" /* Cache.Manual */) {
            postCacheRoutes.push(route);
        }
        else {
            preCacheRoutes.push(route);
        }
    });
    const manifestBundles = bundles.map(({ extension, format, hash }) => ({
        asset: hash + extension,
        format,
    }));
    const manifest = {
        bundles: manifestBundles,
        routes: preCacheRoutes.filter(nonNullable),
        post_cache_routes: postCacheRoutes.filter(nonNullable),
        bundler_version: getPackageVersion(),
        layers,
        import_map: importMap,
    };
    return manifest;
};
const pathToRegularExpression = (path) => {
    // We use the global flag so that `globToRegExp` will not wrap the expression
    // with `^` and `$`. We'll do that ourselves.
    const regularExpression = globToRegExp(path, { flags: 'g' });
    // Wrapping the expression source with `^` and `$`. Also, adding an optional
    // trailing slash, so that a declaration of `path: "/foo"` matches requests
    // for both `/foo` and `/foo/`.
    const normalizedSource = `^${regularExpression.source}\\/?$`;
    return new RegExp(normalizedSource);
};
const getRegularExpression = (declaration) => {
    if ('pattern' in declaration) {
        return new RegExp(declaration.pattern);
    }
    return pathToRegularExpression(declaration.path);
};
const getExcludedRegularExpression = (declaration) => {
    if ('pattern' in declaration && declaration.excludedPattern) {
        return new RegExp(declaration.excludedPattern);
    }
    if ('path' in declaration && declaration.excludedPath) {
        return pathToRegularExpression(declaration.excludedPath);
    }
};
const writeManifest = async ({ bundles, declarations = [], distDirectory, functions, importMap, layers, }) => {
    const manifest = generateManifest({ bundles, declarations, functions, importMap, layers });
    const manifestPath = join(distDirectory, 'manifest.json');
    await fs.writeFile(manifestPath, JSON.stringify(manifest));
    return manifest;
};
export { generateManifest, writeManifest };
